# Smash The Stack - Getting Started In Binary Exploitation


<center>{Eat,Sleep,Pray,Repeat}
"Time to Pray is more important than time to Pwn"

Author {Bayu,Amrul,Agus,Niko,Ramdhan,Riordan,Rhama}@ESP_Repeat</center>


# Introduction
Binary Exploitation adalah proses mencari mencari celah pada sebuah aplikasi, sehingga aplikasi dapat "diakali" cara kerjanya untuk menjalankan suatu fungsi tertentu yang sebenarnya tidak ada dalam aplikasi tersebut, misalnya aplikasi akan memanggil `/bin/sh` untuk _Spawning Shell_, atau bahkan mungkin membaca file-file tertentu seperti /etc/passwd. 
Terkadang dibutuhkan _Skill Reverse Engineering_ untuk mengetahui bagaimana program tersebut bekerja yang akan sangat membantu untuk mengindentifikasi celah yang bisa dieksploitasi. 
Dalam dunia CTF, binary exploitation adalah salah satu kategori tersusah dan point nya tergolong tinggi. Pada mode _Attack & Defense_ challenge-challenge yang diberikan adalah kebanyakan binary exploit, oleh karena itu apabila tidak mempelajari binary exploit kita sendiri tidak akan bisa melakukan _Attack_ apalagi _Defense_. Hasilnya kita tidak akan mendapatkan Flag dan hanya akan menjadi incaran tim lain.

## Memory Layout
Sebelum memulai belajar Binary Exploitation hal paling basic perlu dikuasai adalah layout memory, karena setiap C-Program yang dijalankan akan diload kedalam RAM komputer. Secara umum layout memory (x86) seperti berikut
![](BinaryExploitation/memory/Memory_Layout.png)

 0x00000000  code
 0x08048000  code
 0x08052000  data
 0x0805A000  bss (zero data)
 0x08072000  end of data (brk marker)
 0xBFFFE000  stack
 0xFFFFFFFF  Kernal Space

1. Segment .text
Segment .text atau yang biasa juga dikenal sebagai _Code Segment_ adalah bagian dimana intruksi program berada. Semua intruksi-intruksi program seperti mov, cmp, call dan sebagainya dari _Compiled_ program berada disini.
Letak Segment .text berada "dibawah" _Heap_ dan _Stack_. Tujuannya adalah untuk mencegah _Heap_ ataupun _Stack based overflow_ yang akan menimpa instruksi-intruksi 	code tersebut. Dan "dibawah" maksudnya adalah segment .text berada di alamat yang lebih rendah (_Low Address_) daripada _Heap_ dan _Stack_. Pada dasarnya segment .text dalam keadaan read-only, hal ini karenakan untuk mencegah apabila program tidak sengaja mengubahnya.

2. Segment .data


## Assembly 101
## Essential Tools
### File
File adalah utilitas yang digunakan untuk mengenali tipe suatu file berdasarkan signature atau magic byte. Jadi, apabila signature atau magic byte nya diganti dengan byte-byte sembarang atau memang file tersebut tidak memiliki magic byte, file akan mengkategorikan file tersebut sebagai data.

``` bash
$ file m.gif
m.gif: GIF image data, version 89a, 200 x 230
$ file --mime-type m.gif
m.gif: image/gif
$ file --mime-encoding m.gif
m.gif: binary
$ file modified_m.gif 
modified_m.gif: data
$ file --mime-type modified_m.gif
modified_m.gif: application/octet-stream
$ file --mime-encoding modified_m.gif
modified_m.gif: binary

```


### Strings
Strings adalah utilitas yang digunakan untuk mencari strings pada suatu file, baik itu file berupa plain text maupun binary data.


``` bash
$ strings /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin

$ file hello
hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=2a821c4d4d9783efeca41f4d5c632d09620b1412, not stripped

$ strings hello
/lib64/ld-linux-x86-64.so.2
M\c-	b
libc.so.6
strcpy
__stack_chk_fail
stdout
fputs
__libc_start_main
__gmon_start__
GLIBC_2.4
GLIBC_2.2.5
UH-H
AWAVA
AUATL
[]A\A]A^A_
;*3$"
GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609
crtstuff.c
__JCR_LIST__
deregister_tm_clones
__do_global_dtors_aux
completed.7585
__do_global_dtors_aux_fini_array_entry
frame_dummy
__frame_dummy_init_array_entry
hello.c
__FRAME_END__
__JCR_END__
__init_array_end
_DYNAMIC
__init_array_start
__GNU_EH_FRAME_HDR
_GLOBAL_OFFSET_TABLE_
__libc_csu_fini
_ITM_deregisterTMCloneTable
stdout@@GLIBC_2.2.5
strcpy@@GLIBC_2.2.5
_edata
__stack_chk_fail@@GLIBC_2.4
fputs@@GLIBC_2.2.5
__libc_start_main@@GLIBC_2.2.5
__data_start
__gmon_start__
__dso_handle
_IO_stdin_used
__libc_csu_init
__bss_start
main
_Jv_RegisterClasses
__TMC_END__
_ITM_registerTMCloneTable
.symtab
.strtab
.shstrtab
.interp
.note.ABI-tag
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.plt.got
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.dynamic
.got.plt
.data
.bss
.comment
```

strings juga dapat digunakan untuk mendapatkan offset suatu string tertentu

``` bash
$ strings -t x /lib/x86_64-linux-gnu/libc.so.6 | grep "/bin/sh"
18cd17 /bin/sh
```
### Ltrace
ltrace adalah utilitas yang digunakan untuk melakukan trace terhadap library yang digunakan atau dipanggil saat eksekusi program ELF binary berlangsung, sehingga sangat membantu ketika ingin melakukan debugging terhadap ELF binary.

``` bash
$ ltrace ./hello "Hello World"
__libc_start_main(0x400616, 2, 0x7ffd19aed2a8, 0x400680 <unfinished ...>
strcpy(0x7ffd19aed190, "Hello World")                                                                                  = 0x7ffd19aed190
fputs("Hello World", 0x7fc474cbf620)                                                                                   = 1
Hello World+++ exited (status 0) +++

$ ltrace ./check_passwd p4ssw0rd
__libc_start_main(0x4005d6, 2, 0x7ffd8de900f8, 0x400660 <unfinished ...>
strcmp("S3cr3t_p4ss", "p4ssw0rd")                                                                                      = -29
puts("Password Salah"Password Salah
)                                                                                                 = 15
+++ exited (status 0) +++

$ ltrace ./check_passwd S3cr3t_p4ss
__libc_start_main(0x4005d6, 2, 0x7fff0641d598, 0x400660 <unfinished ...>
strcmp("S3cr3t_p4ss", "S3cr3t_p4ss")                                                                                   = 0
puts("Password Benar"Password Benar
)                                                                                                 = 15
+++ exited (status 0) +++
```

Selain itu, `ltrace` juga bisa melakukan filtering terhadap library yang dipanggil dengan menggunakan parameter `-e FILTER`. Sehingga ltrace hanya akan melakukan tracing terhadap library yang di filter.

```bash
ltrace -e strcmp ./passCheck "AAAA"                                                                                                           
strcmp->strcmp("AAAA", "P4ssw0rd")                                                                      = -15
Access Danied
+++ exited (status 0) +++
```
Apabila library yang di filter tidak ada, ltrace tidak akan mengeluarkan output apapun yang berhubungan dengan process tracing.
```asm
ltrace -e memcmp ./passCheck "AAA"                                                                                                            
Access Danied
+++ exited (status 0) +++
```

Secara default, `ltrace` membatasi string yang diouputkan hanya sampai 32 karakter.

```bash
ltrace -e strcmp ./passCheck_long "nyari_password_nya_susah_amat_ya_mana_Panjang_lagi"
strcmp_long->strcmp("nyari_password_nya_susah_amat_ya"..., "P4ssw0rd_nya_panjang_bngetkan?sa"...) = 30
Access Danied
+++ exited (status 0) +++

```
Untuk membuatnya menjadi unlimited atau sesuai dengan yang diinginkan, bisa di set menggunakan parameter `-s STRSIZE`. Sehingga `ltrace` akan mengeluarkan string sesuai dengan besar `STRSIZE`.

Contoh nya dibawah ini `ltrace` akan melimit string yang di output hingga 100 bytes.
```bashnyari_password_nya_susah_amat_ya_mana_Panjang_lagi
ltrace -s 100 -e strcmp ./passCheck_long "AAA"
strcmp_long->strcmp("nyari_password_nya_susah_amat_ya_mana_Panjang_lagi", "P4ssw0rd_nya_panjang_bngetkan?sampe_enggk_kena_limit_hehe") = -15
Access Danied
+++ exited (status 0) +++
```

### Strace
strace adalah utilitas yang digunakan untuk melakukan trace terhadap system calls dan signal, sangat berbeda dengan ltrace yang melakukan tracing terhadap library yang dipanggil.

``` bash
$ strace ./check_passwd p4ssw0rd
execve("./check_passwd", ["./check_passwd", "p4ssw0rd"], [/* 65 vars */]) = 0
brk(NULL)                               = 0x7f1000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f75fa029000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=148686, ...}) = 0
mmap(NULL, 148686, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f75fa004000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0P\t\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=1868984, ...}) = 0
mmap(NULL, 3971488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f75f9a3c000
mprotect(0x7f75f9bfc000, 2097152, PROT_NONE) = 0
mmap(0x7f75f9dfc000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c0000) = 0x7f75f9dfc000
mmap(0x7f75f9e02000, 14752, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f75f9e02000
close(3)                                = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f75fa003000
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f75fa002000
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f75fa001000
arch_prctl(ARCH_SET_FS, 0x7f75fa002700) = 0
mprotect(0x7f75f9dfc000, 16384, PROT_READ) = 0
mprotect(0x600000, 4096, PROT_READ)     = 0
mprotect(0x7f75fa02b000, 4096, PROT_READ) = 0
munmap(0x7f75fa004000, 148686)          = 0
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 8), ...}) = 0
brk(NULL)                               = 0x7f1000
brk(0x812000)                           = 0x812000
write(1, "Password Salah\n", 15Password Salah
)        = 15
exit_group(0)                           = ?
+++ exited with 0 +++
```
### Nm
Nm adalah utilitas yang digunakan mendapatkan informasi dari symbols yang digunakan oleh object file atau executable file.

Karakter yang digunakan untuk mengidentifikasi symbol :

    A :  Global absolute symbol.
    a  :  Local absolute symbol.
    B : Global bss symbol.
    b : Local bss symbol.
    D : Global data symbol.
    d : Local data symbol.
    f : Source file name symbol.
    L : Global thread-local symbol (TLS).
    l : Static thread-local symbol (TLS).
    T : Global text symbol.
    t  : Local text symbol.
    U : Undefined symbol.


### Objdump
### Readelf
### Gdb and PEDA

GDB atau GNU Debugger adalah debugger yang berjalan di berbagai Unix-Like dan dapat bekerja untuk berbagai bahasa program, seperti C/C++,Pascal,Fotran,Java dll.


Menjalankan GDB
```
$ gdb <binary_name>
```
Meload program apabila sudah berada di gdb
```
(gdb) file <binary_name>
```

Menjalankan program yang sudah di load
```
(gdb) run
```

Disassemble program
```
disas <function_name>
```

Men


### Instalasi PEDA
PEDA atau Python Exploit Development Assistance adalah add on gdb yang mempunyai berbagai macam fitur seperti colorize and display disassembly codes, registers, memory information selama debugging.

Berikut adalah command yang dimiliki PEDA saat melakukan debugging
```
aslr -- Show/set ASLR setting of GDB
checksec -- Check for various security options of binary
dumpargs -- Display arguments passed to a function when stopped at a call instruction
dumprop -- Dump all ROP gadgets in specific memory range
elfheader -- Get headers information from debugged ELF file
elfsymbol -- Get non-debugging symbol information from an ELF file
lookup -- Search for all addresses/references to addresses which belong to a memory range
patch -- Patch memory start at an address with string/hexstring/int
pattern -- Generate, search, or write a cyclic pattern to memory
procinfo -- Display various info from /proc/pid/
pshow -- Show various PEDA options and other settings
pset -- Set various PEDA options and other settings
readelf -- Get headers information from an ELF file
ropgadget -- Get common ROP gadgets of binary or library
ropsearch -- Search for ROP gadgets in memory
searchmem|find -- Search for a pattern in memory; support regex search
shellcode -- Generate or download common shellcodes.
skeleton -- Generate python exploit code template
vmmap -- Get virtual mapping address ranges of section(s) in debugged process
xormem -- XOR a memory region with a key

```

### Command PEDA

*Checksec*
Checksec digunakan untuk mengecek proteksi-proteksi yang ada pada binary yang didebug.
```bash
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : Partial
```


### Pwntools
Pwntools adalah freamwork yang biasa digunakan untuk melakukan exploit development, dalam dunia CTF pwntools sangat berguna untuk menyelesaikan challenge binary exploitation. Pwntools mempunyai berbagai macam fungsi sehingga para CTF players dapat dengan mudah menyusun exploit code untuk challenge-challenge binary exploitation.

#### Instalasi pwntools

Menurut pembuat nya, pwntools support 64-bit Ubuntu LTE release (12.04, 14.04, and 16.04). Dan dapat berjalan dengan baik pada Posix-like distribution (Debian, Arch, FreeBSD, OSX, etc.). Python 2.7 is required.

``` bash
apt-get update
apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential
pip install --upgrade pip
pip install --upgrade pwntools
```

#### Memulai pwntools

Mengimport semua class, atribut dan function pada module pwntools

``` python
$ ipython
>>> from pwn import *
```

##### Class ELF
Class ELF digunakan untuk mendapatkan informasi dari ELF binary

Argument :
	checksec (bool) - untuk melakukan cek proteksi yang ada di ELF binary,
	
berikut contoh program sederhana yang akan digunakan.
``` bash
$ cat hello.c
#include <stdio.h>


int main(void){

	char nama[25];
	printf("Hello World!\n");
	printf("Enter your name : ");
	fgets(nama, sizeof(nama), stdin);
	printf("Your name is : %s\n", nama);
	return 0;

}
$ gcc hello.c -o hello
```

``` python
elf_binary = ELF("./hello")
[*] '/tmp/hello'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)

```
Mendapatkan daftar plt symbol beserta alamat nya

``` python
In [5]: elf_binary.plt
Out[5]: 
{u'__gmon_start__': 4195680,
 u'__libc_start_main': 4195648,
 u'__stack_chk_fail': 4195616,
 u'fgets': 4195664,
 u'printf': 4195632,
 u'puts': 4195596}
```
Mendapatkan daftar GOT Address
``` python
In [6]: elf_binary.got
Out[6]: 
{u'__gmon_start__': 6295544,
 u'__libc_start_main': 6295600,
 u'__stack_chk_fail': 6295584,
 u'fgets': 6295608,
 u'printf': 6295592,
 u'puts': 6295576,
 u'stdin': 6295632}
```
Mencari offset dari string yang terdapat didalam ELF binary

``` python
In [8]: elf_binary.search("name").next()
Out[8]: 4196220
In [9]: hex(elf_binary.search("name").next())
Out[9]: '0x40077c'
In [10]: # mencari offset string /bin/sh pada libc
In [10]: libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
[*] '/lib/x86_64-linux-gnu/libc.so.6'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
In [11]: libc.search("/bin/sh").next()
Out[11]: 1625367
In [12]: hex(libc.search("/bin/sh").next())
Out[12]: '0x18cd17'
```

Melakukan Patching
Berikut adalah source program yang akan dipatching, sehingga fungsi ==system== yang mengeksekusi command ==id== tidak dipanggil.
``` bash
$ cat system.c
#include <stdio.h>
void main(void){
	puts("Hello World");
	system("id");
}
$ gcc system.c -o 
$ ./system
Hello World
uid=1000(pwning) gid=1000(pwning) groups=1000(pwning)
$ objdump -d a.out -M intel
....
0000000000400566 <main>:
  400566:	55                   	push   rbp
  400567:	48 89 e5             	mov    rbp,rsp
  40056a:	bf 14 06 40 00       	mov    edi,0x400614
  40056f:	e8 bc fe ff ff       	call   400430 <puts@plt>
  400574:	bf 20 06 40 00       	mov    edi,0x400620
  400579:	b8 00 00 00 00       	mov    eax,0x0
  40057e:	e8 bd fe ff ff       	call   400440 <system@plt>
  400583:	90                   	nop
  400584:	5d                   	pop    rbp
  400585:	c3                   	ret    
  400586:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  40058d:	00 00 00 
....
```

``` python
In [79]: elf_system = ELF("./system",checksec=False)
In [90]: offset_system = elf_system.search('\xe8\xbd\xfe\xff\xff').next()
In [91]: offset_system
Out[91]: 4195710
In [92]: elf_system.read(offset_system,5)
Out[92]: '\xe8\xbd\xfe\xff\xff'
In [93]: elf_system.write(offset_system,"\x90\x90\x90\x90\x90")
In [94]: elf_system.read(offset_system,5)
Out[94]: '\x90\x90\x90\x90\x90'
In [95]: elf_system.save("system_patched")

```
Percobaan eksekusi system_patched hanya menampilkan string "Hello World"
``` bash
$ ./system_patched
Hello World
```
##### Class remote
Menciptakan TCP-UDP connection ke remote host.

```python
from pwn import *
```

### ROPgadget
### Hopper
### IDA Pro

# Stack Overflow
Buffer Overflow terjadi karena inputan user lebih besar daripada besar buffer suatu variable penampung. Akibatnya inputan pengguna mengoverwrite (Menimpa) "sesuatu" yang tersimpan di _Stack_. Secara umum "sesuatu" tersebut bisa berupa _Local Variable_ ataupun _Return Address_ yang menyebabkan _Attacker_ dapat melakukan kontrol terhadap eksekusi program, misal nya dengan menginject dengan _Shellcode_ untuk melakukan _Spawning Shell_. Hal ini terjadi karena fungsi yang digunakan untuk meminta user input tidak memiliki filter batasan jumlah karakter inputan pengguna. Contoh fungsi yang _Vulnerable_ adalah gets, sprintf, strcpy,fscanf, scanf dan lain-lain.

Oleh karena itu, apabila program meminta user input, pastikan membatasi jumlah karakter inputan user agar tidak terjadi overflow.
## Classic Buffer Overflow
Pada zaman saat buffer overflow pertama kali dipublikasi oleh Aleph One, terdapat banyak sekali serangan yang dilakukan oleh _Attacker_ untuk mengambil alih system,karena belum adanya proteksi yang kuat untuk menghentikan _Buffer Overflow_. 

Tapi dunia security semakin berkembang, terdapat berbagai macam proteksi yang bisa menghentikan _Buffer Overflow_ sehingga membuat _Buffer Overflow_ tidak dapat dieksploitasi lebih lanjut karena dihadang oleh proteksi yang ada saat ini. 
Proteksi-proteksi tersebut ada yang disediakan oleh kernel maupun compiler, proteksi tersebut diantara nya adalah ASLR (Address Space Layout Randomization), NX (No eXecute) yang diberikan oleh kernel dan proteksi yang diberikan dari sisi compiler adalah Stack Canary.

Sebelum memulai "menaklukan" proteksi-proteksi _Buffer Overflow_ ada baiknya kita mempelajari _Classic Buffer Overflow_ sehingga kita mengetahui konsep dari _Buffer Overflow_ itu sendiri lalu baru mencoba melakukan _Bypass_ terhadap proteksi-proteksi nya. Memahami _Classic Buffer Overflow_ hukum nya wajib sebelum naik ke tingkat yang lebih _Advance_ dari teknik-teknik _Binary Exploit_.
## Buffer Overflow - Overwrite Local Variable
## Buffer Overflow - Overwrite Return Address
## Return to Text/Shellcode
## Binary Protection
### ASLR
ASLR atau Address space layout randomization adalah proteksi yang diberikan oleh kernel yang melakukan randomize pada stack, heap, libc, dll. Tujuannya untuk mempersulit Attacker melakukan jump ke posisi tertentu, misal nya ke posisi shellcode yang berada di stack ataupun fungsi yang berada di libc.
### NX
NX atau No-eXecute dari compiler
### PIE
### Stack Canaries
Stack Canaries adalah proteksi yang diberikan oleh compiler, yang dimana apabila nilai canary teroverwrite (overflow) program akan memanggil fungsi _chk_fail yang menyebabkan program akan berhenti secara paksa sebelum program tersebut exit atau selesai. Mulai pada versi gcc 4.1 Stack canaries secara default di enables. Stack canaries juga biasa disebut dengan ProPolice
### PaX

## Return to Register (ret2reg)
## Return to Library (ret2libc)
# Return Oriented Programming
## ROP
### Simple Rop
## Return to PLT (ret2plt)
     
	 
<!-- Classic Exploitation Technique
Linux Binary Protections
Bypassing ASLR with Ret2Reg
Bypassing NX with Return Oriented Programming
Bypassing NX with Ret2Libc
ASLR in Depth
Bypassing ASLR/NX with Ret2PLT
Bypassing ASLR/NX with GOT Overwrite
Multi-Stage Exploits
Advanced Exercises -->


# Referensi
https://security.stackexchange.com/questions/49320/difference-between-binary-exploitation-and-reverse-engineering
https://en.wikipedia.org/wiki/Code_segment
https://en.wikipedia.org/wiki/Data_segment
https://en.wikipedia.org/wiki/.bss
https://github.com/nnamon/linux-exploitation-course